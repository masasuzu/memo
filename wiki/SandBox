{{toc}}

! Python Code Reading 8
!! ヘッダ
* date:
** 2009/03/11
* place:
** ミラクルリナックス(新橋)
* speaker
** ふるかわとおる

!! 概要
* python3.0の利点
** 書きやすさ、読みやすさ
** 言語としての一貫性
* Python3.0の欠点
** 後方互換性がない
*** ユーザが多い
*** 変更点が多い
**** 既存コードが動かなくなる


* 今回のフォーカス
** 3.0でできなくなったこと
*** 2.5.4と3.0.1を比較
** 標準ライブラリを参考
*** テストが通っている

* 標準ライブラリの変更点
** 文字まわり
** 例外まわり

!! print文 → print関数

||! 2.x                ||! 3.0                   ||
|| print …            || print(…)              ||
|| print …,           || print(…, end=“ ”)   ||
|| print               || print()                ||
|| print >>stream, …  || print(…, file=stream) ||

* 改行を出力させたくない場合
<<<
print("Hello, world", end=" ")
>>>

!! 文字列型の変更
* 2.xでは型と用途が不一致していた

||! 2.xの型 ||! 用途         ||! 3.0の型 ||
|| unicode  || Unicode文字列 || str      ||
|| str      || ASCII文字列   || str      ||
|| str      || バイト列      || bytes    ||


* u" "の廃止
* b".."リテラルの追加

*strとbytesを明に変換
<<<
bytes(s, encodeing="...")
str(b, encodeing="...")
>>>


!!! ファイルの扱い
* テキストモードでファイルを開くとread()の戻り値はstr
* バイナリモードでファイルを開くとwrite()にbytesを渡す

!! 例外
* except Exc, var → exept Exc as var

** 2.xのexcept文はややこしい

* raise Exc, arg → rase Exc(arg)

* 文字列例外の廃止
** 2.5非推奨
** 2.6、3.0で廃止

!! iter.next() → next(iter)
* イテレータのnext()メソッドの廃止
** 代わりに__next__()メソッド
** 組み込み関数next()
*** 内部で__next__()メソッドを呼んでいる。

!! 辞書のkeys() items() values() はリストを返さない
* viewというiterableを返す

!! __cmp__() → __lt__()
* __cmp__()による比較を廃止
* 組み込み関数cmp()も廃止
* __lt__()で__cmp__()を代用

!!! __cmp__()は <、==、>
* __cmp__(self,other)の戻り値は、....
** self < otherなら不の値
** self == otherなら0
** self > otherなら正の値

!!! __lt__() は <
* __lt__(self, other)の戻り値は、.....
** self < otherなら真
** else: 偽

!! __getslece__ → __getitem__
* __getitem__に統一

!! その他
* file() → open()
* <>演算子 → !=演算子
* __nonzero__ → __bool__
* d.has_key(key) → key in d

!! 2to3

* 2to3でのコード移行手順
** まずテストコードを書く
** 2.6 で-3オプションをつける
** 2to3でソースコードを変換
** 後は自力でがんばりましょう

!!! 自力で直すところ
* 大小比較には__lt__を定義する必要
* スライスは自力で
* reduce()も自力で
* テキストファイルのエンコード指定

!! まとめ
* 3.0に移行しない理由
** 2.xに依存
** 呼び側2.xに依存

* 3.0に移行すべき理由
** 一貫性
** 書きやすさ、読みやすさ
** 2.xに強く依存していない

* 移行ポイント
** ほとんどは局所的に対応でOK
** 文字列に注意
** 2to3を使いましょう

!! その他
* 文字列まわりの処理は重い?
** 3.1で解消?
* 3.0を実用で使っている人は少ないらしい
* djangoは2年以上かけて3.0に移行するらしい

----


!自動ドキュメント生成プラクティス
ソースコードの内容を自動解析し、ドキュメントを生成します。言語ごとに自動生成用のツールが存在し、これらのツールを使用することにより達成します。

!ドキュメント生成ツールとは
ソースコードに記述されたコメントを抽出し、ドキュメントを生成するツールです。

ソースコードドキュメント生成ツールには大きく下記の2種類の機能を備えております。
* ソースコード解析機能
* マークアップ埋め込み機能

!動機
現状の開発ではプログラム設計書とソースコードを別々に作成･管理しているため、改修のたび双方にメンテナンスが必要となります。同じことが記述されているにもかかわらず別々に管理されいるため、それぞれの同期を取るために多少なりとも稼働が発生してしまいます。また、ソースコード改修時にしばしばドキュメントとの不整合が起こりがちです。

!目的
ドキュメント生成ツールを使用することによりソースコードとドキュメントの不整合をなくしたり、ソースコードとドキュメント管理の煩雑さを軽減することができます。
また、ツールによっては関数の一覧表示やデータ構造の表示など静的解析機能を持つものもあります。これを利用することによりソースコードの解析をすることができます。


!前提
プログラム設計書を記述せずに、内部設計書からプログラムを記述するというプロセスの変更が必要となります。プログラム設計はコメントに記載されることとなります。

コード内にはどんな処理が行われているのか、どのように行われているのかは記述されますが、なぜそのような処理が行われるのかは記述されていません。コメントにはなぜその処理が行われるのかを記載する必要があります。

公開するドキュメントの目的として、ユーザに公開するパブリッシュなコード(メソッド/関数)に関してはAPIの仕様や引数･戻り値、簡単な使用法などユーザ(関数使用者)の視点でコメントを記述します。
ユーザに非公開なプライベートなコードに関してはアルゴリズムなど実装上の情報を記述します。

コメントに頼るのではなく、ソースコードの内容を見ただけで処理が分かるような設計や命名規則を用いることが肝要です。

! 今後の課題
コード修正時には必ずコメントも修正する必要があります。そのため、コメントとコードの不一致をチェックするプロセスが必要となります。

納品物にプログラム設計書が含まれている場合、HTML形式でよいか確認を取る必要があります。HTML形式が許容されない場合、出力されたXMLからword形式のXMLに変更するツールが必要となります。


! 機能概要
!! ソースコード解析機能
ソースコードを解析し、クラス、関数、データ構造などを一覧を作成することができます。相互参照部分にHTMLのハイパーリンクを張ってくれるツールもあります。また、ツールによってはクラス図やコールグラフなど、ソースの構造を自動で作図することも可能です。

!! マークアップ埋め込み機能
ドキュメント内にドキュメント用のタグを埋め込むと、その部分をツールが解析しドキュメントを生成します。HTMLタグを埋め込むことも可能です。
また、ツールによってはテキストから作図することも可能です。

!各ツール概要
||! ツール ||! 言語            ||! 解析||! 埋め込み ||! 備考                           ||
||! perldoc|| perl             || ×   || ○        || CPAN登録ライブラリで使用        ||
||! Doxygen|| C/C++ Python PHP || ○   || ○        || 多言語に対応                    ||
||! Epydoc || Python           || ○   || ○        || Pythonに特化 高機能             ||
||! Javadoc|| Java             || ○   || ○        || Javaの標準APIドキュメントで使用 ||
